#lang racket
(put 'negate 'rational (lambda(x) (make-rational (- 0 (numer x)) (- 0 (denom x)))))
(put 'negate 'complex (lambda(x) (make-complex (- 0 (real-part x)) (- 0 (imag-part x)))))
(define (negate x)
  (apply-generic 'negate x))

(define (install-poly-package)
  (define (make-poly var term-list)
    (list var term-list))
  (define (variable p) (car p))
  (define (term-list p) (cadr p)) ;Dense polynomial assumed
  (define (make-term order coeff)
    (list order coeff))
  (define (order t) (car t))
  (define (coeff t) (cadr t))
  (define (adjoin-term t tl)
    (if (= (coeff t) 0)
        tl
        (cond ((null? tl) (list t))
              ((<(order (first-term tl)) (order t))
               (cons t tl))
              (else (cons (car tl) (adjoin-term t (cdr tl)))))))
  (define (first-term tl) (car tl))
  (define (rest-terms tl) (cdr tl))
  (define (degree tl) (order (first-term tl)))
  (define (add-terms tl1 tl2)
    (let ((deg1 (deg tl1))
          (deg2 (deg tl2)))
      (cond((null? tl1) tl2)
           ((null? tl2) tl1)
           ((< deg1 deg2)
            (cons (first-term tl2) (add-terms tl1 (rest-terms tl2))))
           ((> deg1 deg2)
            (cons (first-term tl1) (add-terms (rest-terms tl1) tl2)))
           (else
            (cons (make-term deg1 (add (coeff (first-term tl1))
                                       (coeff (first-term tl2))))
                  (add-terms (rest-terms tl1) (rest-terms tl2)))))))
  (define (mul-terms tl1 tl2)
    (if (or(mul? tl1) (mul? tl2))
        '()
        (add-terms (map (lambda(term) (make-term (+ (order term) (deg tl1)) (mul (coeff term) (coeff (first-term tl1))) tl2) (mul-terms (rest-terms tl1) tl2))))))
  (define (sub-terms tl1 tl2)
    (add-terms tl1 (map (lambda(term) (make-term (order term) (negate (coeff term)))) tl2)))
  (define (div-terms tl1 tl2)
    (if (null? tl1)
        (list '() '())
        (let ((t1 (first-term tl1))
              (t2 (first-term tl2)))
          (if (<(order t1)(order t2))
              (list '() tl1)
              (let ((new-o (-(order t1) (order t2)))
                    (new-c (/(coeff t1) (coeff t2))))
                (let ((new-term (make-term new-o new-c)))
                  (let ((new-divid (sub-terms tl1 (mul-terms new-term tl2))))
                    (let ((next (div-terms new-div tl2)))
                      (list (adjoin-term new-term (car next)) (cdr next))))))))))
  (define (pseudo-remainder-terms p q)
    (let ((c (coeff (first-term q)))
          (O1 (order (first-term p)))
          (O2 (order (first-term q))))
      (let ((int-factor (expt c (+ 1 (- O1  O2)))))
        (cadr (div-terms (* int-factor p) q)))))
  (define (reduce-termlist p)
    (
  